{"version":3,"sources":["exif.js","index.js"],"names":["debug","EXIF","obj","EXIFwrapped","exports","module","ExifTags","Tags","TiffTags","GPSTags","IFD1Tags","StringValues","ExposureProgram","MeteringMode","LightSource","Flash","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","Components","imageHasData","img","exifdata","getImageData","callback","handleBinaryFile","binFile","data","findEXIFinJPEG","iptcdata","findIPTCinJPEG","file","dataView","DataView","console","log","byteLength","getUint8","offset","length","isFieldSegmentStart","nameHeaderLength","startOffset","sectionLength","getUint16","readIPTCData","call","src","test","base64ToArrayBuffer","base64","contentType","match","replace","binary","atob","len","buffer","ArrayBuffer","view","Uint8Array","i","charCodeAt","fileReader","FileReader","onload","e","target","result","objectURLToBlob","url","http","XMLHttpRequest","open","responseType","status","response","send","blob","readAsArrayBuffer","self","Blob","File","marker","readEXIFData","IptcFieldMap","segmentStartPos","fieldValue","fieldName","dataSize","segmentType","getInt16","getStringFromDB","hasOwnProperty","Array","push","readTags","tiffStart","dirStart","strings","bigEnd","entries","entryOffset","tag","tags","readTagValue","type","vals","val","n","numerator","denominator","numValues","getUint32","valueOffset","Number","getInt32","start","outstr","String","fromCharCode","exifData","gpsData","tiffOffset","firstIFDOffset","ExifIFDPointer","GPSInfoIFDPointer","readThumbnailImage","IFD1OffsetPointer","getNextIFDOffset","thumbTags","JpegIFOffset","JpegIFByteCount","tOffset","tLength","getData","Image","HTMLImageElement","complete","getTag","getIptcTag","getAllTags","a","getAllIptcTags","pretty","strPretty","readFromBinaryFile","define","amd","DEFAULT_CONFIG","quality","maxWidth","maxHeight","autoRotate","mimeType","readAndCompressImage","userConfig","Promise","resolve","document","createElement","reader","config","Object","assign","orientation","scaleImage","error","readAsDataURL","canvas","width","height","ctx","getContext","save","exifApplied","findMaxWidth","getHalfScaleCanvas","scaleCanvasWithAlgorithm","outputWidth","imageData","toDataURL","dataURIToBlob","onScale","ratio","mWidth","Math","min","maxSize","floor","scaleRatio","warning","styleWidth","style","styleHeight","translate","scale","rotate","PI","drawImage","restore","dataURI","byteString","split","mimeString","ab","ia","scaledCanvas","srcImgData","destImgData","createImageData","applyBilinearInterpolation","putImageData","halfCanvas","srcCanvasData","destCanvasData","inner","f00","f10","f01","f11","x","y","un_x","un_y","j","iyv","iy0","iy1","ixv","ix0","ix1","idxD","idxS00","idxS10","idxS01","idxS11","dx","dy","r","g","b","ceil"],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":["(function() {\n  \n      var debug = false;\n  \n      var root = this;\n  \n      var EXIF = function(obj) {\n          if (obj instanceof EXIF) return obj;\n          if (!(this instanceof EXIF)) return new EXIF(obj);\n          this.EXIFwrapped = obj;\n      };\n  \n      if (typeof exports !== 'undefined') {\n          if (typeof module !== 'undefined' && module.exports) {\n              exports = module.exports = EXIF;\n          }\n          exports.EXIF = EXIF;\n      } else {\n          root.EXIF = EXIF;\n      }\n  \n      var ExifTags = EXIF.Tags = {\n  \n          // version tags\n          0x9000 : \"ExifVersion\",             // EXIF version\n          0xA000 : \"FlashpixVersion\",         // Flashpix format version\n  \n          // colorspace tags\n          0xA001 : \"ColorSpace\",              // Color space information tag\n  \n          // image configuration\n          0xA002 : \"PixelXDimension\",         // Valid width of meaningful image\n          0xA003 : \"PixelYDimension\",         // Valid height of meaningful image\n          0x9101 : \"ComponentsConfiguration\", // Information about channels\n          0x9102 : \"CompressedBitsPerPixel\",  // Compressed bits per pixel\n  \n          // user information\n          0x927C : \"MakerNote\",               // Any desired information written by the manufacturer\n          0x9286 : \"UserComment\",             // Comments by user\n  \n          // related file\n          0xA004 : \"RelatedSoundFile\",        // Name of related sound file\n  \n          // date and time\n          0x9003 : \"DateTimeOriginal\",        // Date and time when the original image was generated\n          0x9004 : \"DateTimeDigitized\",       // Date and time when the image was stored digitally\n          0x9290 : \"SubsecTime\",              // Fractions of seconds for DateTime\n          0x9291 : \"SubsecTimeOriginal\",      // Fractions of seconds for DateTimeOriginal\n          0x9292 : \"SubsecTimeDigitized\",     // Fractions of seconds for DateTimeDigitized\n  \n          // picture-taking conditions\n          0x829A : \"ExposureTime\",            // Exposure time (in seconds)\n          0x829D : \"FNumber\",                 // F number\n          0x8822 : \"ExposureProgram\",         // Exposure program\n          0x8824 : \"SpectralSensitivity\",     // Spectral sensitivity\n          0x8827 : \"ISOSpeedRatings\",         // ISO speed rating\n          0x8828 : \"OECF\",                    // Optoelectric conversion factor\n          0x9201 : \"ShutterSpeedValue\",       // Shutter speed\n          0x9202 : \"ApertureValue\",           // Lens aperture\n          0x9203 : \"BrightnessValue\",         // Value of brightness\n          0x9204 : \"ExposureBias\",            // Exposure bias\n          0x9205 : \"MaxApertureValue\",        // Smallest F number of lens\n          0x9206 : \"SubjectDistance\",         // Distance to subject in meters\n          0x9207 : \"MeteringMode\",            // Metering mode\n          0x9208 : \"LightSource\",             // Kind of light source\n          0x9209 : \"Flash\",                   // Flash status\n          0x9214 : \"SubjectArea\",             // Location and area of main subject\n          0x920A : \"FocalLength\",             // Focal length of the lens in mm\n          0xA20B : \"FlashEnergy\",             // Strobe energy in BCPS\n          0xA20C : \"SpatialFrequencyResponse\",    //\n          0xA20E : \"FocalPlaneXResolution\",   // Number of pixels in width direction per FocalPlaneResolutionUnit\n          0xA20F : \"FocalPlaneYResolution\",   // Number of pixels in height direction per FocalPlaneResolutionUnit\n          0xA210 : \"FocalPlaneResolutionUnit\",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n          0xA214 : \"SubjectLocation\",         // Location of subject in image\n          0xA215 : \"ExposureIndex\",           // Exposure index selected on camera\n          0xA217 : \"SensingMethod\",           // Image sensor type\n          0xA300 : \"FileSource\",              // Image source (3 == DSC)\n          0xA301 : \"SceneType\",               // Scene type (1 == directly photographed)\n          0xA302 : \"CFAPattern\",              // Color filter array geometric pattern\n          0xA401 : \"CustomRendered\",          // Special processing\n          0xA402 : \"ExposureMode\",            // Exposure mode\n          0xA403 : \"WhiteBalance\",            // 1 = auto white balance, 2 = manual\n          0xA404 : \"DigitalZoomRation\",       // Digital zoom ratio\n          0xA405 : \"FocalLengthIn35mmFilm\",   // Equivalent foacl length assuming 35mm film camera (in mm)\n          0xA406 : \"SceneCaptureType\",        // Type of scene\n          0xA407 : \"GainControl\",             // Degree of overall image gain adjustment\n          0xA408 : \"Contrast\",                // Direction of contrast processing applied by camera\n          0xA409 : \"Saturation\",              // Direction of saturation processing applied by camera\n          0xA40A : \"Sharpness\",               // Direction of sharpness processing applied by camera\n          0xA40B : \"DeviceSettingDescription\",    //\n          0xA40C : \"SubjectDistanceRange\",    // Distance to subject\n  \n          // other tags\n          0xA005 : \"InteroperabilityIFDPointer\",\n          0xA420 : \"ImageUniqueID\"            // Identifier assigned uniquely to each image\n      };\n  \n      var TiffTags = EXIF.TiffTags = {\n          0x0100 : \"ImageWidth\",\n          0x0101 : \"ImageHeight\",\n          0x8769 : \"ExifIFDPointer\",\n          0x8825 : \"GPSInfoIFDPointer\",\n          0xA005 : \"InteroperabilityIFDPointer\",\n          0x0102 : \"BitsPerSample\",\n          0x0103 : \"Compression\",\n          0x0106 : \"PhotometricInterpretation\",\n          0x0112 : \"Orientation\",\n          0x0115 : \"SamplesPerPixel\",\n          0x011C : \"PlanarConfiguration\",\n          0x0212 : \"YCbCrSubSampling\",\n          0x0213 : \"YCbCrPositioning\",\n          0x011A : \"XResolution\",\n          0x011B : \"YResolution\",\n          0x0128 : \"ResolutionUnit\",\n          0x0111 : \"StripOffsets\",\n          0x0116 : \"RowsPerStrip\",\n          0x0117 : \"StripByteCounts\",\n          0x0201 : \"JPEGInterchangeFormat\",\n          0x0202 : \"JPEGInterchangeFormatLength\",\n          0x012D : \"TransferFunction\",\n          0x013E : \"WhitePoint\",\n          0x013F : \"PrimaryChromaticities\",\n          0x0211 : \"YCbCrCoefficients\",\n          0x0214 : \"ReferenceBlackWhite\",\n          0x0132 : \"DateTime\",\n          0x010E : \"ImageDescription\",\n          0x010F : \"Make\",\n          0x0110 : \"Model\",\n          0x0131 : \"Software\",\n          0x013B : \"Artist\",\n          0x8298 : \"Copyright\"\n      };\n  \n      var GPSTags = EXIF.GPSTags = {\n          0x0000 : \"GPSVersionID\",\n          0x0001 : \"GPSLatitudeRef\",\n          0x0002 : \"GPSLatitude\",\n          0x0003 : \"GPSLongitudeRef\",\n          0x0004 : \"GPSLongitude\",\n          0x0005 : \"GPSAltitudeRef\",\n          0x0006 : \"GPSAltitude\",\n          0x0007 : \"GPSTimeStamp\",\n          0x0008 : \"GPSSatellites\",\n          0x0009 : \"GPSStatus\",\n          0x000A : \"GPSMeasureMode\",\n          0x000B : \"GPSDOP\",\n          0x000C : \"GPSSpeedRef\",\n          0x000D : \"GPSSpeed\",\n          0x000E : \"GPSTrackRef\",\n          0x000F : \"GPSTrack\",\n          0x0010 : \"GPSImgDirectionRef\",\n          0x0011 : \"GPSImgDirection\",\n          0x0012 : \"GPSMapDatum\",\n          0x0013 : \"GPSDestLatitudeRef\",\n          0x0014 : \"GPSDestLatitude\",\n          0x0015 : \"GPSDestLongitudeRef\",\n          0x0016 : \"GPSDestLongitude\",\n          0x0017 : \"GPSDestBearingRef\",\n          0x0018 : \"GPSDestBearing\",\n          0x0019 : \"GPSDestDistanceRef\",\n          0x001A : \"GPSDestDistance\",\n          0x001B : \"GPSProcessingMethod\",\n          0x001C : \"GPSAreaInformation\",\n          0x001D : \"GPSDateStamp\",\n          0x001E : \"GPSDifferential\"\n      };\n  \n       // EXIF 2.3 Spec\n      var IFD1Tags = EXIF.IFD1Tags = {\n          0x0100: \"ImageWidth\",\n          0x0101: \"ImageHeight\",\n          0x0102: \"BitsPerSample\",\n          0x0103: \"Compression\",\n          0x0106: \"PhotometricInterpretation\",\n          0x0111: \"StripOffsets\",\n          0x0112: \"Orientation\",\n          0x0115: \"SamplesPerPixel\",\n          0x0116: \"RowsPerStrip\",\n          0x0117: \"StripByteCounts\",\n          0x011A: \"XResolution\",\n          0x011B: \"YResolution\",\n          0x011C: \"PlanarConfiguration\",\n          0x0128: \"ResolutionUnit\",\n          0x0201: \"JpegIFOffset\",    // When image format is JPEG, this value show offset to JPEG data stored.(aka \"ThumbnailOffset\" or \"JPEGInterchangeFormat\")\n          0x0202: \"JpegIFByteCount\", // When image format is JPEG, this value shows data size of JPEG image (aka \"ThumbnailLength\" or \"JPEGInterchangeFormatLength\")\n          0x0211: \"YCbCrCoefficients\",\n          0x0212: \"YCbCrSubSampling\",\n          0x0213: \"YCbCrPositioning\",\n          0x0214: \"ReferenceBlackWhite\"\n      };\n  \n      var StringValues = EXIF.StringValues = {\n          ExposureProgram : {\n              0 : \"Not defined\",\n              1 : \"Manual\",\n              2 : \"Normal program\",\n              3 : \"Aperture priority\",\n              4 : \"Shutter priority\",\n              5 : \"Creative program\",\n              6 : \"Action program\",\n              7 : \"Portrait mode\",\n              8 : \"Landscape mode\"\n          },\n          MeteringMode : {\n              0 : \"Unknown\",\n              1 : \"Average\",\n              2 : \"CenterWeightedAverage\",\n              3 : \"Spot\",\n              4 : \"MultiSpot\",\n              5 : \"Pattern\",\n              6 : \"Partial\",\n              255 : \"Other\"\n          },\n          LightSource : {\n              0 : \"Unknown\",\n              1 : \"Daylight\",\n              2 : \"Fluorescent\",\n              3 : \"Tungsten (incandescent light)\",\n              4 : \"Flash\",\n              9 : \"Fine weather\",\n              10 : \"Cloudy weather\",\n              11 : \"Shade\",\n              12 : \"Daylight fluorescent (D 5700 - 7100K)\",\n              13 : \"Day white fluorescent (N 4600 - 5400K)\",\n              14 : \"Cool white fluorescent (W 3900 - 4500K)\",\n              15 : \"White fluorescent (WW 3200 - 3700K)\",\n              17 : \"Standard light A\",\n              18 : \"Standard light B\",\n              19 : \"Standard light C\",\n              20 : \"D55\",\n              21 : \"D65\",\n              22 : \"D75\",\n              23 : \"D50\",\n              24 : \"ISO studio tungsten\",\n              255 : \"Other\"\n          },\n          Flash : {\n              0x0000 : \"Flash did not fire\",\n              0x0001 : \"Flash fired\",\n              0x0005 : \"Strobe return light not detected\",\n              0x0007 : \"Strobe return light detected\",\n              0x0009 : \"Flash fired, compulsory flash mode\",\n              0x000D : \"Flash fired, compulsory flash mode, return light not detected\",\n              0x000F : \"Flash fired, compulsory flash mode, return light detected\",\n              0x0010 : \"Flash did not fire, compulsory flash mode\",\n              0x0018 : \"Flash did not fire, auto mode\",\n              0x0019 : \"Flash fired, auto mode\",\n              0x001D : \"Flash fired, auto mode, return light not detected\",\n              0x001F : \"Flash fired, auto mode, return light detected\",\n              0x0020 : \"No flash function\",\n              0x0041 : \"Flash fired, red-eye reduction mode\",\n              0x0045 : \"Flash fired, red-eye reduction mode, return light not detected\",\n              0x0047 : \"Flash fired, red-eye reduction mode, return light detected\",\n              0x0049 : \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n              0x004D : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n              0x004F : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n              0x0059 : \"Flash fired, auto mode, red-eye reduction mode\",\n              0x005D : \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n              0x005F : \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\n          },\n          SensingMethod : {\n              1 : \"Not defined\",\n              2 : \"One-chip color area sensor\",\n              3 : \"Two-chip color area sensor\",\n              4 : \"Three-chip color area sensor\",\n              5 : \"Color sequential area sensor\",\n              7 : \"Trilinear sensor\",\n              8 : \"Color sequential linear sensor\"\n          },\n          SceneCaptureType : {\n              0 : \"Standard\",\n              1 : \"Landscape\",\n              2 : \"Portrait\",\n              3 : \"Night scene\"\n          },\n          SceneType : {\n              1 : \"Directly photographed\"\n          },\n          CustomRendered : {\n              0 : \"Normal process\",\n              1 : \"Custom process\"\n          },\n          WhiteBalance : {\n              0 : \"Auto white balance\",\n              1 : \"Manual white balance\"\n          },\n          GainControl : {\n              0 : \"None\",\n              1 : \"Low gain up\",\n              2 : \"High gain up\",\n              3 : \"Low gain down\",\n              4 : \"High gain down\"\n          },\n          Contrast : {\n              0 : \"Normal\",\n              1 : \"Soft\",\n              2 : \"Hard\"\n          },\n          Saturation : {\n              0 : \"Normal\",\n              1 : \"Low saturation\",\n              2 : \"High saturation\"\n          },\n          Sharpness : {\n              0 : \"Normal\",\n              1 : \"Soft\",\n              2 : \"Hard\"\n          },\n          SubjectDistanceRange : {\n              0 : \"Unknown\",\n              1 : \"Macro\",\n              2 : \"Close view\",\n              3 : \"Distant view\"\n          },\n          FileSource : {\n              3 : \"DSC\"\n          },\n  \n          Components : {\n              0 : \"\",\n              1 : \"Y\",\n              2 : \"Cb\",\n              3 : \"Cr\",\n              4 : \"R\",\n              5 : \"G\",\n              6 : \"B\"\n          }\n      };\n  \n      function addEvent(element, event, handler) {\n          if (element.addEventListener) {\n              element.addEventListener(event, handler, false);\n          } else if (element.attachEvent) {\n              element.attachEvent(\"on\" + event, handler);\n          }\n      }\n  \n      function imageHasData(img) {\n          return !!(img.exifdata);\n      }\n  \n  \n      function base64ToArrayBuffer(base64, contentType) {\n          contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n          base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n          var binary = atob(base64);\n          var len = binary.length;\n          var buffer = new ArrayBuffer(len);\n          var view = new Uint8Array(buffer);\n          for (var i = 0; i < len; i++) {\n              view[i] = binary.charCodeAt(i);\n          }\n          return buffer;\n      }\n  \n      function objectURLToBlob(url, callback) {\n          var http = new XMLHttpRequest();\n          http.open(\"GET\", url, true);\n          http.responseType = \"blob\";\n          http.onload = function(e) {\n              if (this.status == 200 || this.status === 0) {\n                  callback(this.response);\n              }\n          };\n          http.send();\n      }\n  \n      function getImageData(img, callback) {\n          function handleBinaryFile(binFile) {\n              var data = findEXIFinJPEG(binFile);\n              var iptcdata = findIPTCinJPEG(binFile);\n              // var xmpdata= findXMPinJPEG(binFile);\n              img.exifdata = data || {};\n              img.iptcdata = iptcdata || {};\n              // img.xmpdata = xmpdata || {};\n              if (callback) {\n                  callback.call(img);\n              }\n          }\n  \n          if (img.src) {\n              if (/^data\\:/i.test(img.src)) { // Data URI\n                  var arrayBuffer = base64ToArrayBuffer(img.src);\n                  handleBinaryFile(arrayBuffer);\n  \n              } else if (/^blob\\:/i.test(img.src)) { // Object URL\n                  var fileReader = new FileReader();\n                  fileReader.onload = function(e) {\n                      handleBinaryFile(e.target.result);\n                  };\n                  objectURLToBlob(img.src, function (blob) {\n                      fileReader.readAsArrayBuffer(blob);\n                  });\n              } else {\n                  var http = new XMLHttpRequest();\n                  http.onload = function() {\n                      if (this.status == 200 || this.status === 0) {\n                          handleBinaryFile(http.response);\n                      } else {\n                          throw \"Could not load image\";\n                      }\n                      http = null;\n                  };\n                  http.open(\"GET\", img.src, true);\n                  http.responseType = \"arraybuffer\";\n                  http.send(null);\n              }\n          } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {\n              var fileReader = new FileReader();\n              fileReader.onload = function(e) {\n                  if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\n                  handleBinaryFile(e.target.result);\n              };\n  \n              fileReader.readAsArrayBuffer(img);\n          }\n      }\n  \n      function findEXIFinJPEG(file) {\n          var dataView = new DataView(file);\n  \n          if (debug) console.log(\"Got file of length \" + file.byteLength);\n          if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n              if (debug) console.log(\"Not a valid JPEG\");\n              return false; // not a valid jpeg\n          }\n  \n          var offset = 2,\n              length = file.byteLength,\n              marker;\n  \n          while (offset < length) {\n              if (dataView.getUint8(offset) != 0xFF) {\n                  if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\n                  return false; // not a valid marker, something is wrong\n              }\n  \n              marker = dataView.getUint8(offset + 1);\n              if (debug) console.log(marker);\n  \n              // we could implement handling for other markers here,\n              // but we're only looking for 0xFFE1 for EXIF data\n  \n              if (marker == 225) {\n                  if (debug) console.log(\"Found 0xFFE1 marker\");\n  \n                  return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\n  \n                  // offset += 2 + file.getShortAt(offset+2, true);\n  \n              } else {\n                  offset += 2 + dataView.getUint16(offset+2);\n              }\n  \n          }\n  \n      }\n  \n      function findIPTCinJPEG(file) {\n          var dataView = new DataView(file);\n  \n          if (debug) console.log(\"Got file of length \" + file.byteLength);\n          if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n              if (debug) console.log(\"Not a valid JPEG\");\n              return false; // not a valid jpeg\n          }\n  \n          var offset = 2,\n              length = file.byteLength;\n  \n  \n          var isFieldSegmentStart = function(dataView, offset){\n              return (\n                  dataView.getUint8(offset) === 0x38 &&\n                  dataView.getUint8(offset+1) === 0x42 &&\n                  dataView.getUint8(offset+2) === 0x49 &&\n                  dataView.getUint8(offset+3) === 0x4D &&\n                  dataView.getUint8(offset+4) === 0x04 &&\n                  dataView.getUint8(offset+5) === 0x04\n              );\n          };\n  \n          while (offset < length) {\n  \n              if ( isFieldSegmentStart(dataView, offset )){\n  \n                  // Get the length of the name header (which is padded to an even number of bytes)\n                  var nameHeaderLength = dataView.getUint8(offset+7);\n                  if(nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\n                  // Check for pre photoshop 6 format\n                  if(nameHeaderLength === 0) {\n                      // Always 4\n                      nameHeaderLength = 4;\n                  }\n  \n                  var startOffset = offset + 8 + nameHeaderLength;\n                  var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n  \n                  return readIPTCData(file, startOffset, sectionLength);\n  \n                  break;\n  \n              }\n  \n  \n              // Not the marker, continue searching\n              offset++;\n  \n          }\n  \n      }\n      var IptcFieldMap = {\n          0x78 : 'caption',\n          0x6E : 'credit',\n          0x19 : 'keywords',\n          0x37 : 'dateCreated',\n          0x50 : 'byline',\n          0x55 : 'bylineTitle',\n          0x7A : 'captionWriter',\n          0x69 : 'headline',\n          0x74 : 'copyright',\n          0x0F : 'category'\n      };\n      function readIPTCData(file, startOffset, sectionLength){\n          var dataView = new DataView(file);\n          var data = {};\n          var fieldValue, fieldName, dataSize, segmentType, segmentSize;\n          var segmentStartPos = startOffset;\n          while(segmentStartPos < startOffset+sectionLength) {\n              if(dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos+1) === 0x02){\n                  segmentType = dataView.getUint8(segmentStartPos+2);\n                  if(segmentType in IptcFieldMap) {\n                      dataSize = dataView.getInt16(segmentStartPos+3);\n                      segmentSize = dataSize + 5;\n                      fieldName = IptcFieldMap[segmentType];\n                      fieldValue = getStringFromDB(dataView, segmentStartPos+5, dataSize);\n                      // Check if we already stored a value with this name\n                      if(data.hasOwnProperty(fieldName)) {\n                          // Value already stored with this name, create multivalue field\n                          if(data[fieldName] instanceof Array) {\n                              data[fieldName].push(fieldValue);\n                          }\n                          else {\n                              data[fieldName] = [data[fieldName], fieldValue];\n                          }\n                      }\n                      else {\n                          data[fieldName] = fieldValue;\n                      }\n                  }\n  \n              }\n              segmentStartPos++;\n          }\n          return data;\n      }\n  \n  \n  \n      function readTags(file, tiffStart, dirStart, strings, bigEnd) {\n          var entries = file.getUint16(dirStart, !bigEnd),\n              tags = {},\n              entryOffset, tag,\n              i;\n  \n          for (i=0;i<entries;i++) {\n              entryOffset = dirStart + i*12 + 2;\n              tag = strings[file.getUint16(entryOffset, !bigEnd)];\n              if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\n              tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\n          }\n          return tags;\n      }\n  \n  \n      function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n          var type = file.getUint16(entryOffset+2, !bigEnd),\n              numValues = file.getUint32(entryOffset+4, !bigEnd),\n              valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,\n              offset,\n              vals, val, n,\n              numerator, denominator;\n  \n          switch (type) {\n              case 1: // byte, 8-bit unsigned int\n              case 7: // undefined, 8-bit byte, value depending on field\n                  if (numValues == 1) {\n                      return file.getUint8(entryOffset + 8, !bigEnd);\n                  } else {\n                      offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n                      vals = [];\n                      for (n=0;n<numValues;n++) {\n                          vals[n] = file.getUint8(offset + n);\n                      }\n                      return vals;\n                  }\n  \n              case 2: // ascii, 8-bit byte\n                  offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n                  return getStringFromDB(file, offset, numValues-1);\n  \n              case 3: // short, 16 bit int\n                  if (numValues == 1) {\n                      return file.getUint16(entryOffset + 8, !bigEnd);\n                  } else {\n                      offset = numValues > 2 ? valueOffset : (entryOffset + 8);\n                      vals = [];\n                      for (n=0;n<numValues;n++) {\n                          vals[n] = file.getUint16(offset + 2*n, !bigEnd);\n                      }\n                      return vals;\n                  }\n  \n              case 4: // long, 32 bit int\n                  if (numValues == 1) {\n                      return file.getUint32(entryOffset + 8, !bigEnd);\n                  } else {\n                      vals = [];\n                      for (n=0;n<numValues;n++) {\n                          vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);\n                      }\n                      return vals;\n                  }\n  \n              case 5:    // rational = two long values, first is numerator, second is denominator\n                  if (numValues == 1) {\n                      numerator = file.getUint32(valueOffset, !bigEnd);\n                      denominator = file.getUint32(valueOffset+4, !bigEnd);\n                      val = new Number(numerator / denominator);\n                      val.numerator = numerator;\n                      val.denominator = denominator;\n                      return val;\n                  } else {\n                      vals = [];\n                      for (n=0;n<numValues;n++) {\n                          numerator = file.getUint32(valueOffset + 8*n, !bigEnd);\n                          denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);\n                          vals[n] = new Number(numerator / denominator);\n                          vals[n].numerator = numerator;\n                          vals[n].denominator = denominator;\n                      }\n                      return vals;\n                  }\n  \n              case 9: // slong, 32 bit signed int\n                  if (numValues == 1) {\n                      return file.getInt32(entryOffset + 8, !bigEnd);\n                  } else {\n                      vals = [];\n                      for (n=0;n<numValues;n++) {\n                          vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);\n                      }\n                      return vals;\n                  }\n  \n              case 10: // signed rational, two slongs, first is numerator, second is denominator\n                  if (numValues == 1) {\n                      return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);\n                  } else {\n                      vals = [];\n                      for (n=0;n<numValues;n++) {\n                          vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);\n                      }\n                      return vals;\n                  }\n          }\n      }\n  \n      /**\n      * Given an IFD (Image File Directory) start offset\n      * returns an offset to next IFD or 0 if it's the last IFD.\n      */\n      function getNextIFDOffset(dataView, dirStart, bigEnd){\n          //the first 2bytes means the number of directory entries contains in this IFD\n          var entries = dataView.getUint16(dirStart, !bigEnd);\n  \n          // After last directory entry, there is a 4bytes of data,\n          // it means an offset to next IFD.\n          // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\n  \n          return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long\n      }\n  \n      function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd){\n          // get the IFD1 offset\n          var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart+firstIFDOffset, bigEnd);\n  \n          if (!IFD1OffsetPointer) {\n              // console.log('******** IFD1Offset is empty, image thumb not found ********');\n              return {};\n          }\n          else if (IFD1OffsetPointer > dataView.byteLength) { // this should not happen\n              // console.log('******** IFD1Offset is outside the bounds of the DataView ********');\n              return {};\n          }\n          // console.log('*******  thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);\n  \n          var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd)\n  \n          // EXIF 2.3 specification for JPEG format thumbnail\n  \n          // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\n          // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\n          // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\n          // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\n          // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\n  \n          if (thumbTags['Compression']) {\n              // console.log('Thumbnail image found!');\n  \n              switch (thumbTags['Compression']) {\n                  case 6:\n                      // console.log('Thumbnail image format is JPEG');\n                      if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {\n                      // extract the thumbnail\n                          var tOffset = tiffStart + thumbTags.JpegIFOffset;\n                          var tLength = thumbTags.JpegIFByteCount;\n                          thumbTags['blob'] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {\n                              type: 'image/jpeg'\n                          });\n                      }\n                  break;\n  \n              case 1:\n                  console.log(\"Thumbnail image format is TIFF, which is not implemented.\");\n                  break;\n              default:\n                  console.log(\"Unknown thumbnail image format '%s'\", thumbTags['Compression']);\n              }\n          }\n          else if (thumbTags['PhotometricInterpretation'] == 2) {\n              console.log(\"Thumbnail image format is RGB, which is not implemented.\");\n          }\n          return thumbTags;\n      }\n  \n      function getStringFromDB(buffer, start, length) {\n          var outstr = \"\";\n          for (var n = start; n < start+length; n++) {\n              outstr += String.fromCharCode(buffer.getUint8(n));\n          }\n          return outstr;\n      }\n  \n      function readEXIFData(file, start) {\n          if (getStringFromDB(file, start, 4) != \"Exif\") {\n              if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\n              return false;\n          }\n  \n          var bigEnd,\n              tags, tag,\n              exifData, gpsData,\n              tiffOffset = start + 6;\n  \n          // test for TIFF validity and endianness\n          if (file.getUint16(tiffOffset) == 0x4949) {\n              bigEnd = false;\n          } else if (file.getUint16(tiffOffset) == 0x4D4D) {\n              bigEnd = true;\n          } else {\n              if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\n              return false;\n          }\n  \n          if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {\n              if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\n              return false;\n          }\n  \n          var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);\n  \n          if (firstIFDOffset < 0x00000008) {\n              if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset+4, !bigEnd));\n              return false;\n          }\n  \n          tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\n  \n          if (tags.ExifIFDPointer) {\n              exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\n              for (tag in exifData) {\n                  switch (tag) {\n                      case \"LightSource\" :\n                      case \"Flash\" :\n                      case \"MeteringMode\" :\n                      case \"ExposureProgram\" :\n                      case \"SensingMethod\" :\n                      case \"SceneCaptureType\" :\n                      case \"SceneType\" :\n                      case \"CustomRendered\" :\n                      case \"WhiteBalance\" :\n                      case \"GainControl\" :\n                      case \"Contrast\" :\n                      case \"Saturation\" :\n                      case \"Sharpness\" :\n                      case \"SubjectDistanceRange\" :\n                      case \"FileSource\" :\n                          exifData[tag] = StringValues[tag][exifData[tag]];\n                          break;\n  \n                      case \"ExifVersion\" :\n                      case \"FlashpixVersion\" :\n                          exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\n                          break;\n  \n                      case \"ComponentsConfiguration\" :\n                          exifData[tag] =\n                              StringValues.Components[exifData[tag][0]] +\n                              StringValues.Components[exifData[tag][1]] +\n                              StringValues.Components[exifData[tag][2]] +\n                              StringValues.Components[exifData[tag][3]];\n                          break;\n                  }\n                  tags[tag] = exifData[tag];\n              }\n          }\n  \n          if (tags.GPSInfoIFDPointer) {\n              gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\n              for (tag in gpsData) {\n                  switch (tag) {\n                      case \"GPSVersionID\" :\n                          gpsData[tag] = gpsData[tag][0] +\n                              \".\" + gpsData[tag][1] +\n                              \".\" + gpsData[tag][2] +\n                              \".\" + gpsData[tag][3];\n                          break;\n                  }\n                  tags[tag] = gpsData[tag];\n              }\n          }\n  \n          // extract thumbnail\n          tags['thumbnail'] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);\n  \n          return tags;\n      }\n  \n     function findXMPinJPEG(file) {\n  \n          if (!('DOMParser' in self)) {\n              // console.warn('XML parsing not supported without DOMParser');\n              return;\n          }\n          var dataView = new DataView(file);\n  \n          if (debug) console.log(\"Got file of length \" + file.byteLength);\n          if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n             if (debug) console.log(\"Not a valid JPEG\");\n             return false; // not a valid jpeg\n          }\n  \n          var offset = 2,\n              length = file.byteLength,\n              dom = new DOMParser();\n  \n          while (offset < (length-4)) {\n              if (getStringFromDB(dataView, offset, 4) == \"http\") {\n                  var startOffset = offset - 1;\n                  var sectionLength = dataView.getUint16(offset - 2) - 1;\n                  var xmpString = getStringFromDB(dataView, startOffset, sectionLength)\n                  var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;\n                  xmpString = xmpString.substring( xmpString.indexOf( '<x:xmpmeta' ), xmpEndIndex );\n  \n                  var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10\n                  //Many custom written programs embed xmp/xml without any namespace. Following are some of them.\n                  //Without these namespaces, XML is thought to be invalid by parsers\n                  xmpString = xmpString.slice(0, indexOfXmp)\n                              + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" '\n                              + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" '\n                              + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" '\n                              + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" '\n                              + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" '\n                              + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" '\n                              + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" '\n                              + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" '\n                              + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" '\n                              + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" '\n                              + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" '\n                              + xmpString.slice(indexOfXmp)\n  \n                  var domDocument = dom.parseFromString( xmpString, 'text/xml' );\n                  return xml2Object(domDocument);\n              } else{\n               offset++;\n              }\n          }\n      }\n  \n      function xml2Object(xml) {\n          try {\n              var obj = {};\n              if (xml.children.length > 0) {\n                for (var i = 0; i < xml.children.length; i++) {\n                  var item = xml.children.item(i);\n                  var attributes = item.attributes;\n                  for(var idx in attributes) {\n                      var itemAtt = attributes[idx];\n                      var dataKey = itemAtt.nodeName;\n                      var dataValue = itemAtt.nodeValue;\n  \n                      if(dataKey !== undefined) {\n                          obj[dataKey] = dataValue;\n                      }\n                  }\n                  var nodeName = item.nodeName;\n  \n                  if (typeof (obj[nodeName]) == \"undefined\") {\n                    obj[nodeName] = xml2json(item);\n                  } else {\n                    if (typeof (obj[nodeName].push) == \"undefined\") {\n                      var old = obj[nodeName];\n  \n                      obj[nodeName] = [];\n                      obj[nodeName].push(old);\n                    }\n                    obj[nodeName].push(xml2json(item));\n                  }\n                }\n              } else {\n                obj = xml.textContent;\n              }\n              return obj;\n            } catch (e) {\n                console.log(e.message);\n            }\n      }\n  \n      EXIF.getData = function(img, callback) {\n          if (((self.Image && img instanceof self.Image)\n              || (self.HTMLImageElement && img instanceof self.HTMLImageElement))\n              && !img.complete)\n              return false;\n  \n          if (!imageHasData(img)) {\n              getImageData(img, callback);\n          } else {\n              if (callback) {\n                  callback.call(img);\n              }\n          }\n          return true;\n      }\n  \n      EXIF.getTag = function(img, tag) {\n          if (!imageHasData(img)) return;\n          return img.exifdata[tag];\n      }\n      \n      EXIF.getIptcTag = function(img, tag) {\n          if (!imageHasData(img)) return;\n          return img.iptcdata[tag];\n      }\n  \n      EXIF.getAllTags = function(img) {\n          if (!imageHasData(img)) return {};\n          var a,\n              data = img.exifdata,\n              tags = {};\n          for (a in data) {\n              if (data.hasOwnProperty(a)) {\n                  tags[a] = data[a];\n              }\n          }\n          return tags;\n      }\n      \n      EXIF.getAllIptcTags = function(img) {\n          if (!imageHasData(img)) return {};\n          var a,\n              data = img.iptcdata,\n              tags = {};\n          for (a in data) {\n              if (data.hasOwnProperty(a)) {\n                  tags[a] = data[a];\n              }\n          }\n          return tags;\n      }\n  \n      EXIF.pretty = function(img) {\n          if (!imageHasData(img)) return \"\";\n          var a,\n              data = img.exifdata,\n              strPretty = \"\";\n          for (a in data) {\n              if (data.hasOwnProperty(a)) {\n                  if (typeof data[a] == \"object\") {\n                      if (data[a] instanceof Number) {\n                          strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\n                      } else {\n                          strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\n                      }\n                  } else {\n                      strPretty += a + \" : \" + data[a] + \"\\r\\n\";\n                  }\n              }\n          }\n          return strPretty;\n      }\n  \n      EXIF.readFromBinaryFile = function(file) {\n          return findEXIFinJPEG(file);\n      }\n  \n      if (typeof define === 'function' && define.amd) {\n          define('exif-js', [], function() {\n              return EXIF;\n          });\n      }\n  }.call(this));\n  \n  ","import EXIF from './exif';\n\nconst DEFAULT_CONFIG = {\n  quality: 0.5,\n  maxWidth: 800,\n  maxHeight: 600,\n  autoRotate: true,\n  debug: false,\n  mimeType: 'image/jpeg'\n};\n\nexport default function readAndCompressImage(file, userConfig) {\n  return new Promise(resolve => {\n    var img = document.createElement('img');\n    var reader = new FileReader();\n    var config = Object.assign({}, DEFAULT_CONFIG, userConfig);\n\n    reader.onload = function(e) {\n      img.src = e.target.result;\n      img.onload = function() {\n        if (config.autoRotate) {\n          if (config.debug)\n            console.log('browser-image-resizer: detecting image orientation...');\n          if (\n            typeof EXIF.getData === 'function' &&\n            typeof EXIF.getTag === 'function'\n          ) {\n            EXIF.getData(img, function() {\n              var orientation = EXIF.getTag(this, 'Orientation');\n              if (config.debug) {\n                console.log(\n                  'browser-image-resizer: image orientation from EXIF tag = ' +\n                    orientation\n                );\n              }\n              resolve(scaleImage(img, config, orientation));\n            });\n          } else {\n            console.error(\n              \"browser-image-resizer: can't read EXIF data, the Exif.js library not found\"\n            );\n            resolve (scaleImage(img, config));\n          }\n        }\n      };\n    };\n\n    reader.readAsDataURL(file);\n  });\n}\n\nexport function scaleImage(img, config, orientation = 1) {\n  var canvas = document.createElement('canvas');\n  canvas.width = img.width;\n  canvas.height = img.height;\n  var ctx = canvas.getContext('2d');\n  ctx.save();\n\n  // EXIF\n  exifApplied(canvas, ctx, orientation, img);\n\n  let maxWidth = findMaxWidth(config, canvas);\n\n  while (canvas.width >= 2 * maxWidth) {\n    canvas = getHalfScaleCanvas(canvas);\n  }\n\n  if (canvas.width > maxWidth) {\n    canvas = scaleCanvasWithAlgorithm(canvas, Object.assign(config, { outputWidth: maxWidth }));\n  }\n\n  let imageData = canvas.toDataURL(config.mimeType, config.quality);\n  if (typeof config.onScale === 'function') config.onScale(imageData);\n  return dataURIToBlob(imageData);\n}\n\nfunction findMaxWidth(config, canvas) {\n  //Let's find the max available width for scaled image\n  var ratio = canvas.width / canvas.height;\n  var mWidth = Math.min(canvas.width, config.maxWidth, ratio * config.maxHeight);\n  if (\n    config.maxSize > 0 &&\n    config.maxSize < canvas.width * canvas.height / 1000\n  )\n    mWidth = Math.min(\n      mWidth,\n      Math.floor(config.maxSize * 1000 / canvas.height)\n    );\n  if (!!config.scaleRatio)\n    mWidth = Math.min(\n      mWidth,\n      Math.floor(config.scaleRatio * canvas.width)\n    );\n\n  if (config.debug) {\n    console.log(\n      'browser-image-resizer: original image size = ' +\n        canvas.width +\n        ' px (width) X ' +\n        canvas.height +\n        ' px (height)'\n    );\n    console.log(\n      'browser-image-resizer: scaled image size = ' +\n        mWidth +\n        ' px (width) X ' +\n        Math.floor(mWidth / ratio) +\n        ' px (height)'\n    );\n  }\n  if (mWidth <= 0) {\n    mWidth = 1;\n    console.warning('browser-image-resizer: image size is too small');\n  }\n\n  return mWidth;\n}\n\nfunction exifApplied(canvas, ctx, orientation, img) {\n  var width = canvas.width;\n  var styleWidth = canvas.style.width;\n  var height = canvas.height;\n  var styleHeight = canvas.style.height;\n  if (orientation > 4) {\n    canvas.width = height;\n    canvas.style.width = styleHeight;\n    canvas.height = width;\n    canvas.style.height = styleWidth;\n  }\n  switch (orientation) {\n    case 2:\n      ctx.translate(width, 0);\n      ctx.scale(-1, 1);\n      break;\n    case 3:\n      ctx.translate(width, height);\n      ctx.rotate(Math.PI);\n      break;\n    case 4:\n      ctx.translate(0, height);\n      ctx.scale(1, -1);\n      break;\n    case 5:\n      ctx.rotate(0.5 * Math.PI);\n      ctx.scale(1, -1);\n      break;\n    case 6:\n      ctx.rotate(0.5 * Math.PI);\n      ctx.translate(0, -height);\n      break;\n    case 7:\n      ctx.rotate(0.5 * Math.PI);\n      ctx.translate(width, -height);\n      ctx.scale(-1, 1);\n      break;\n    case 8:\n      ctx.rotate(-0.5 * Math.PI);\n      ctx.translate(-width, 0);\n      break;\n  }\n  ctx.drawImage(img, 0, 0);\n  ctx.restore();\n}\n\nfunction dataURIToBlob(dataURI) {\n  // convert base64 to raw binary data held in a string\n  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\n  var byteString = atob(dataURI.split(',')[1]);\n\n  // separate out the mime component\n  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];\n\n  // write the bytes of the string to an ArrayBuffer\n  var ab = new ArrayBuffer(byteString.length);\n\n  // create a view into the buffer\n  var ia = new Uint8Array(ab);\n\n  // set the bytes of the buffer to the correct values\n  for (var i = 0; i < byteString.length; i++) {\n    ia[i] = byteString.charCodeAt(i);\n  }\n\n  // write the ArrayBuffer to a blob, and you're done\n  var blob = new Blob([ab], { type: mimeString });\n  return blob;\n}\n\nfunction scaleCanvasWithAlgorithm(canvas, config) {\n  var scaledCanvas = document.createElement('canvas');\n\n  var scale = config.outputWidth / canvas.width;\n\n  scaledCanvas.width = canvas.width * scale;\n  scaledCanvas.height = canvas.height * scale;\n\n  var srcImgData = canvas\n    .getContext('2d')\n    .getImageData(0, 0, canvas.width, canvas.height);\n  var destImgData = scaledCanvas\n    .getContext('2d')\n    .createImageData(scaledCanvas.width, scaledCanvas.height);\n\n  applyBilinearInterpolation(srcImgData, destImgData, scale);\n\n  scaledCanvas.getContext('2d').putImageData(destImgData, 0, 0);\n\n  return scaledCanvas;\n}\n\nfunction getHalfScaleCanvas(canvas) {\n  var halfCanvas = document.createElement('canvas');\n  halfCanvas.width = canvas.width / 2;\n  halfCanvas.height = canvas.height / 2;\n\n  halfCanvas\n    .getContext('2d')\n    .drawImage(canvas, 0, 0, halfCanvas.width, halfCanvas.height);\n\n  return halfCanvas;\n}\n\nfunction applyBilinearInterpolation(srcCanvasData, destCanvasData, scale) {\n  function inner(f00, f10, f01, f11, x, y) {\n    var un_x = 1.0 - x;\n    var un_y = 1.0 - y;\n    return f00 * un_x * un_y + f10 * x * un_y + f01 * un_x * y + f11 * x * y;\n  }\n  var i, j;\n  var iyv, iy0, iy1, ixv, ix0, ix1;\n  var idxD, idxS00, idxS10, idxS01, idxS11;\n  var dx, dy;\n  var r, g, b, a;\n  for (i = 0; i < destCanvasData.height; ++i) {\n    iyv = i / scale;\n    iy0 = Math.floor(iyv);\n    // Math.ceil can go over bounds\n    iy1 = Math.ceil(iyv) > srcCanvasData.height - 1\n      ? srcCanvasData.height - 1\n      : Math.ceil(iyv);\n    for (j = 0; j < destCanvasData.width; ++j) {\n      ixv = j / scale;\n      ix0 = Math.floor(ixv);\n      // Math.ceil can go over bounds\n      ix1 = Math.ceil(ixv) > srcCanvasData.width - 1\n        ? srcCanvasData.width - 1\n        : Math.ceil(ixv);\n      idxD = (j + destCanvasData.width * i) * 4;\n      // matrix to vector indices\n      idxS00 = (ix0 + srcCanvasData.width * iy0) * 4;\n      idxS10 = (ix1 + srcCanvasData.width * iy0) * 4;\n      idxS01 = (ix0 + srcCanvasData.width * iy1) * 4;\n      idxS11 = (ix1 + srcCanvasData.width * iy1) * 4;\n      // overall coordinates to unit square\n      dx = ixv - ix0;\n      dy = iyv - iy0;\n      // I let the r, g, b, a on purpose for debugging\n      r = inner(\n        srcCanvasData.data[idxS00],\n        srcCanvasData.data[idxS10],\n        srcCanvasData.data[idxS01],\n        srcCanvasData.data[idxS11],\n        dx,\n        dy\n      );\n      destCanvasData.data[idxD] = r;\n\n      g = inner(\n        srcCanvasData.data[idxS00 + 1],\n        srcCanvasData.data[idxS10 + 1],\n        srcCanvasData.data[idxS01 + 1],\n        srcCanvasData.data[idxS11 + 1],\n        dx,\n        dy\n      );\n      destCanvasData.data[idxD + 1] = g;\n\n      b = inner(\n        srcCanvasData.data[idxS00 + 2],\n        srcCanvasData.data[idxS10 + 2],\n        srcCanvasData.data[idxS01 + 2],\n        srcCanvasData.data[idxS11 + 2],\n        dx,\n        dy\n      );\n      destCanvasData.data[idxD + 2] = b;\n\n      a = inner(\n        srcCanvasData.data[idxS00 + 3],\n        srcCanvasData.data[idxS10 + 3],\n        srcCanvasData.data[idxS01 + 3],\n        srcCanvasData.data[idxS11 + 3],\n        dx,\n        dy\n      );\n      destCanvasData.data[idxD + 3] = a;\n    }\n  }\n}\n"]}